"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.objectOf=exports.arrayOf=exports.isValidOrThrow=exports.isValidOrThrowAllErrors=exports.isValidOrLogAllErrors=exports.hasErrors=exports.isValidOrLog=exports.isValid=exports.checkShape=exports.GeneratorFunction=exports.AsyncFunction=void 0;var _utils=require("./utils.js");require("./polyfills.js");const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;exports.AsyncFunction=AsyncFunction;const GeneratorFunction=Object.getPrototypeOf(function*(){}).constructor;exports.GeneratorFunction=GeneratorFunction;const formatErrorMessage=(type,value,path=null)=>`${path?`on path /${path.join("/")} `:""}value ${(0,_utils.stringify)(value)} do not match type ${(0,_utils.stringify)(type)}`;const onErrorDefault=(err,{type,value,path})=>{if(err)throw err;throw new TypeError(formatErrorMessage(type,value,path))};const onFinishSuccessDefault=()=>true;const onFinishWithErrorsDefault=errors=>{if(errors.length===1)throw errors[0];throw new AggregateError(errors,"aggregateError")};const defaultConfiguration={onError:onErrorDefault,collectAllErrors:false,onFinishSuccess:onFinishSuccessDefault,onFinishWithErrors:onFinishWithErrorsDefault};const checkShape=(conf,schema,object,path=[])=>{if(!isValidType(conf,[v=>v instanceof Object,String],object))return conf.onError(null,{type:schema,value:object});let requiredErrors=[];const requiredKeys=Object.keys(schema).filter(_utils.isRequiredKey);for(const keyName of requiredKeys){try{const currentPath=[...path,keyName];let valid=isValidType(conf,schema[keyName],object[keyName],object,keyName,currentPath);if(valid)continue;return conf.onError(null,{type:schema[keyName],value:object[keyName],path:currentPath})}catch(error){if(!conf.collectAllErrors){throw error}requiredErrors.push(...(0,_utils.parseToArray)(error))}}const optionalError=[];const optionalKeys=Object.keys(schema).filter(_utils.isOptionalKey).filter(key=>!requiredKeys.includes(key.replace(_utils.optionalRegex,"")));for(const keyName of optionalKeys){try{const keyNameStripped=keyName.replace(_utils.optionalRegex,"");const currentPath=[...path,keyNameStripped];let valid=isValidType(conf,[undefined,schema[keyName]],object[keyNameStripped],object,keyNameStripped,currentPath);if(valid)continue;return conf.onError(null,{type:schema[keyName],value:object[keyNameStripped],path:currentPath})}catch(error){if(!conf.collectAllErrors){throw error}optionalError.push(...(0,_utils.parseToArray)(error))}}let regexErrors=[];const regexKeys=Object.keys(schema).filter(_utils.isRegExp);const untestedKeys=Object.keys(object).filter(key=>!requiredKeys.includes(key)).filter(key=>!optionalKeys.map(k=>k.replace(_utils.optionalRegex,"")).includes(key));for(const regexpString of regexKeys){let keys=untestedKeys.filter(keyName=>(0,_utils.stringToRegExp)(regexpString).test(keyName));for(const keyName of keys){try{const currentPath=[...path,keyName];let valid=isValidType(conf,schema[regexpString],object[keyName],object,keyName,currentPath);if(valid)continue;return conf.onError(null,{type:schema[regexpString],value:object[keyName],path:currentPath})}catch(error){if(!conf.collectAllErrors){throw error}regexErrors.push(...(0,_utils.parseToArray)(error))}}}const errors=[...regexErrors,...requiredErrors,...optionalError];if(errors.length>0){throw errors}return true};exports.checkShape=checkShape;const isValidType=(conf=defaultConfiguration,type,value,rootValue,keyName,path)=>{const kind=(0,_utils.whatTypeIs)(type);switch(kind){case"regex":return(0,_utils.checkRegExp)(type,value);case"primitive":return value===type;case"constructor":return(0,_utils.checkConstructor)(type,value);case"enum":return type.some(_type=>isValidType(conf,_type,value,rootValue,keyName));case"schema":checkShape(conf,type,value,path);return true;case"function":return type(value,rootValue,keyName);default:return false;}};const run=conf=>(...types)=>value=>{const errors=[];for(const type of types){try{const valid=isValidType(conf,type,value);if(valid)continue;throw conf.onError(null,{type,value})}catch(error){errors.push(...(0,_utils.parseToArray)(error));if(!conf.collectAllErrors)break}}if(errors.length>0){return conf.onFinishWithErrors(errors)}return conf.onFinishSuccess()};const config=({onError=onErrorDefault,collectAllErrors=false,onFinishSuccess=onFinishSuccessDefault,onFinishWithErrors=onFinishWithErrorsDefault}=defaultConfiguration)=>run({onError,collectAllErrors,onFinishSuccess,onFinishWithErrors});const logOnErrorAndReturnFalse=(err,{type,value,path})=>console.error(err||formatErrorMessage(type,value,path))||false;const isValid=config({onFinishWithErrors:()=>false});exports.isValid=isValid;const isValidOrLog=config({onError:logOnErrorAndReturnFalse});exports.isValidOrLog=isValidOrLog;const hasErrors=config({onFinishWithErrors:errors=>errors,onFinishSuccess:()=>null,collectAllErrors:true});exports.hasErrors=hasErrors;const isValidOrLogAllErrors=config({onFinishWithErrors:()=>false,onError:logOnErrorAndReturnFalse,collectAllErrors:true});exports.isValidOrLogAllErrors=isValidOrLogAllErrors;const isValidOrThrowAllErrors=config({collectAllErrors:true});exports.isValidOrThrowAllErrors=isValidOrThrowAllErrors;const isValidOrThrow=config({});exports.isValidOrThrow=isValidOrThrow;const arrayOf=type=>isValidOrThrow(Array,{[/^\d$/]:type});exports.arrayOf=arrayOf;const objectOf=type=>isValidOrThrow(Object,{[/./]:type});exports.objectOf=objectOf;var _default=isValidOrThrow;exports.default=_default;