"use strict";Object.defineProperty(exports,"__esModule",{value:true});Object.defineProperty(exports,"AsyncFunction",{enumerable:true,get:function(){return _constants.AsyncFunction}});Object.defineProperty(exports,"GeneratorFunction",{enumerable:true,get:function(){return _constants.GeneratorFunction}});exports.default=exports.objectOf=exports.arrayOf=exports.isValidOrThrow=exports.isValidOrThrowAllErrors=exports.isValidOrLogAllErrors=exports.hasErrors=exports.isValidOrLog=exports.isValid=exports.SeriesValidationError=exports.SchemaValidationError=exports.EnumValidationError=void 0;var _utils=require("./utils.js");var _constants=require("./constants.js");class EnumValidationError extends AggregateError{constructor(errors,msg,data){super(errors,msg);this.name="EnumValidationError";this.rawData=data}}exports.EnumValidationError=EnumValidationError;class SchemaValidationError extends AggregateError{constructor(errors,msg,data){super(errors,msg);this.name="SchemaValidationError";this.rawData=data}}exports.SchemaValidationError=SchemaValidationError;class SeriesValidationError extends AggregateError{constructor(errors,msg,data){super(errors,msg);this.name="SeriesValidationError";this.rawData=data}}exports.SeriesValidationError=SeriesValidationError;const formatErrorMessage=(type,value,path=[])=>`${path.length?`on path /${path.join("/")} `:""}value ${(0,_utils.stringify)(value)} do not match type ${(0,_utils.stringify)(type)}`;const throwError=({type,value,path,$Error=TypeError})=>{throw new $Error(formatErrorMessage(type,value,path),{type,value,path})};const throwErrors=(errors,{type,value,path,$Error=AggregateError})=>{if(errors.length===1)throw errors[0];throw new $Error(errors,formatErrorMessage(type,value,path),{type,value,path})};const validOrThrow=(input,data)=>{if(input)return true;throwError(data)};const onFinishSuccessDefault=()=>true;const onFinishWithErrorDefault=error=>{throw error};const defaultConfiguration={collectAllErrors:false,onFinishSuccess:onFinishSuccessDefault,onFinishWithError:onFinishWithErrorDefault};const validSchemaOrThrow=({conf,type:schema,value:object,path=[]})=>{if(!(object instanceof Object||typeof object==="string")){return throwError({type:schema,value:object})}let requiredErrors=[];const requiredKeys=Object.keys(schema).filter(_utils.isRequiredKey);for(const keyName of requiredKeys){try{const currentPath=[...path,keyName];isValidTypeOrThrow(conf,schema[keyName],object[keyName],object,keyName,currentPath)}catch(error){if(!conf.collectAllErrors){throw error}requiredErrors.push(error)}}const optionalError=[];const optionalKeys=Object.keys(schema).filter(_utils.isOptionalKey).filter(key=>!requiredKeys.includes(key.replace(_utils.optionalRegex,"")));for(const keyName of optionalKeys){try{const keyNameStripped=keyName.replace(_utils.optionalRegex,"");const currentPath=[...path,keyNameStripped];let type=schema[keyName];let value=object[keyNameStripped];(0,_utils.isNullish)(value)||isValidTypeOrThrow(conf,type,value,object,keyNameStripped,currentPath)}catch(error){if(!conf.collectAllErrors){throw error}optionalError.push(error)}}let regexErrors=[];const regexKeys=Object.keys(schema).filter(_utils.isRegExp);const untestedKeys=Object.keys(object).filter(key=>!requiredKeys.includes(key)).filter(key=>!optionalKeys.map(k=>k.replace(_utils.optionalRegex,"")).includes(key));for(const regexpString of regexKeys){let keys=untestedKeys.filter(keyName=>(0,_utils.stringToRegExp)(regexpString).test(keyName));for(const keyName of keys){try{const currentPath=[...path,keyName];isValidTypeOrThrow(conf,schema[regexpString],object[keyName],object,keyName,currentPath)}catch(error){if(!conf.collectAllErrors){throw error}regexErrors.push(error)}}}const errors=[...regexErrors,...requiredErrors,...optionalError];if(errors.length>0){throwErrors(errors,{type:schema,value:object,$Error:SchemaValidationError})}return true};const validCustomValidatorOrThrow=(fn,value,root,keyName,path)=>validOrThrow(fn(value,root,keyName),{type:fn,value,root,keyName,path});const validConstructorOrThrow=(type,value,root,keyName,path)=>validOrThrow((0,_utils.checkConstructor)(type,value),{type,value,root,keyName,path});const validPrimitiveOrThrow=(type,value,root,keyName,path)=>validOrThrow(value===type,{type,value,root,keyName,path});const validRegExpOrThrow=(type,value,root,keyName,path)=>validOrThrow(value.constructor===String&&(0,_utils.checkRegExp)(type,value),{type,value,root,keyName,path});const validSeriesOrThrow=(conf,types,value)=>{const errors=[];for(const type of types){try{isValidTypeOrThrow(conf,type,value)}catch(error){errors.push(error);if(!conf.collectAllErrors)break}}if(errors.length>0){throwErrors(errors,{type:types,value,$Error:SeriesValidationError})}return true};const validEnumOrThrow=(conf,types,value,root,keyName,path)=>{const errors=[];for(const type of types){try{if(isValidTypeOrThrow(conf,type,value,root,keyName,path)){return true}}catch(error){errors.push(error)}}throwErrors(errors,{type:types,value,path,$Error:EnumValidationError})};const isValidTypeOrThrow=(conf,type,value,root,keyName,path)=>{switch((0,_utils.whatTypeIs)(type)){case"regex":return validRegExpOrThrow(type,value,root,keyName,path);case"primitive":return validPrimitiveOrThrow(type,value,root,keyName,path);case"constructor":return validConstructorOrThrow(type,value,root,keyName,path);case"enum":return validEnumOrThrow(conf,type,value,root,keyName,path);case"schema":return validSchemaOrThrow({conf,type,value,root,keyName,path});case"validator":return validCustomValidatorOrThrow(type,value,root,keyName,path);case"invalid":throw new SyntaxError(`checking with validator ${(0,_utils.stringify)(type)} not supported`);}};const run=conf=>(...types)=>value=>{try{validSeriesOrThrow(conf,types,value)}catch(error){return conf.onFinishWithError(error)}return conf.onFinishSuccess()};const config=({collectAllErrors=false,onFinishSuccess=onFinishSuccessDefault,onFinishWithError=onFinishWithErrorDefault}=defaultConfiguration)=>run({collectAllErrors,onFinishSuccess,onFinishWithError});const logErrorsAndReturnFalse=error=>{const errors=flatAggregateError(error);errors.forEach(e=>console.error(e));return false};const isValid=config({onFinishWithError:()=>false});exports.isValid=isValid;const isValidOrLog=config({onFinishWithError:logErrorsAndReturnFalse});exports.isValidOrLog=isValidOrLog;const flatAggregateError=error=>{if(error instanceof AggregateError){let errors=error.errors.flatMap(flatAggregateError);return errors}else{return[error]}};const hasErrors=config({onFinishWithError:error=>flatAggregateError(error),onFinishSuccess:()=>null,collectAllErrors:true});exports.hasErrors=hasErrors;const isValidOrLogAllErrors=config({onFinishWithError:logErrorsAndReturnFalse,collectAllErrors:true});exports.isValidOrLogAllErrors=isValidOrLogAllErrors;const isValidOrThrowAllErrors=config({collectAllErrors:true});exports.isValidOrThrowAllErrors=isValidOrThrowAllErrors;const isValidOrThrow=config();exports.isValidOrThrow=isValidOrThrow;const arrayOf=type=>isValidOrThrow(Array,{[/^\d$/]:type});exports.arrayOf=arrayOf;const objectOf=type=>isValidOrThrow(Object,{[/./]:type});exports.objectOf=objectOf;var _default=isValidOrThrow;exports.default=_default;