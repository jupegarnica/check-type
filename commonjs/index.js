"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.isConstructor=isConstructor;exports.default=exports.isValidOrThrow=exports.isValidOrLog=exports.isValid=exports.setOnError=exports.stringify=exports.isValidType=exports.checkShape=exports.isPrimitive=exports.isInstanceOf=exports.isNormalFunction=exports.isType=void 0;const isType=type=>val=>![undefined,null].includes(val)&&val.constructor===type;exports.isType=isType;const isNormalFunction=f=>f&&typeof f==="function"&&(!f.name||f.name[0]===f.name[0].toLowerCase());exports.isNormalFunction=isNormalFunction;function isConstructor(f){if(isNormalFunction(f))return false;if(f&&f.name==="Symbol")return true;try{new f;return true}catch(err){return false}}const isInstanceOf=type=>val=>val instanceof type;exports.isInstanceOf=isInstanceOf;const isPrimitive=value=>!isInstanceOf(Object)(value);exports.isPrimitive=isPrimitive;const checkObject=(whatToDo,types,props)=>{const propsTypes=Object.keys(types).filter(notIsRegExp);let areAllValid=propsTypes.every(propName=>{return whatToDo(types[propName],props[propName],props,propName)});if(!areAllValid)return areAllValid;const regExpToCheck=Object.keys(types).filter(isRegExp);const untestedReceivedProps=Object.keys(props).filter(key=>!propsTypes.includes(key));areAllValid=regExpToCheck.every(regexpString=>untestedReceivedProps.every(propName=>{if(stringToRegExp(regexpString).test(propName)){return whatToDo(types[regexpString],props[propName],props,propName)}return true}));return areAllValid};const checkShape=(types,props)=>checkObject(isValidType,types,props);exports.checkShape=checkShape;const whatKindIs=type=>{if(isType(Object)(type))return"schema";if(isPrimitive(type))return"primitive";if(isConstructor(type))return"constructor";if(isNormalFunction(type))return"function";if(isType(Array)(type))return"enum";if(isType(RegExp)(type))return"regex"};const isValidType=(type,value,rootValue,keyName)=>{const kind=whatKindIs(type);switch(kind){case"regex":return checkRegExp(type,value);case"primitive":return value===type;case"constructor":return isType(type)(value);case"enum":return type.some(_type=>isValidType(_type,value,rootValue,keyName));case"schema":return value&&checkShape(type,value);case"function":return type(value,rootValue,keyName);default:return false;}};exports.isValidType=isValidType;const parser=()=>{const seen=new WeakMap;return(key,value)=>{if(typeof value==="object"&&value!==null){if(seen.has(value)){const oldKey=seen.get(value);return`[circular reference] -> ${oldKey||"rootObject"}`}seen.set(value,key)}if(typeof value==="function"){return value.toString()}return value}};const stringify=val=>JSON.stringify(val,parser());exports.stringify=stringify;const checkRegExp=(regExp,value)=>regExp.test(value);const stringToRegExp=string=>new RegExp(eval(string));const isRegExp=value=>value&&/^\/.+\/$/.test(value);const notIsRegExp=value=>!isRegExp(value);const isError=e=>e&&e.stack&&e.message;const throwOnError=err=>{if(isError(err))throw err;throw new TypeError(err)};const check=error=>(...types)=>value=>{try{return types.every(type=>{const valid=isValidType(type,value);if(valid)return valid;throw`value ${stringify(value)} do not match type ${stringify(type)}`})}catch(err){return error(err)}};const setOnError=onError=>check(onError);exports.setOnError=setOnError;const isValid=setOnError(()=>false);exports.isValid=isValid;const isValidOrLog=setOnError(err=>{console.error(err);return false});exports.isValidOrLog=isValidOrLog;const isValidOrThrow=setOnError(throwOnError);exports.isValidOrThrow=isValidOrThrow;var _default=isValidOrThrow;exports.default=_default;