"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.isValidOrThrow=exports.isValidOrThrowAllError=exports.isValidOrLogAllError=exports.hasErrors=exports.isValidOrLog=exports.isValid=exports.config=exports.isValidType=exports.checkShapeCollectAllErrors=exports.checkShapeCollectOneError=void 0;var _utils=require("./utils.js");if(typeof AggregateError==="undefined"){class AggregateError extends Error{constructor(errors,message){super(message);this.errors=errors}}global.AggregateError=AggregateError}const formatErrorMessage=(type,value,path=null)=>`${path?`on path /${path.join("/")} `:""}value ${(0,_utils.stringify)(value)} do not match type ${(0,_utils.stringify)(type)}`;const throwOnError=err=>{if((0,_utils.isError)(err))throw err;throw new TypeError(err)};const onFinishSuccessDefault=()=>true;const onFinishWithErrorsDefault=errors=>{if(errors.length===1)throwOnError(errors[0]);throw new AggregateError(errors,"aggregateError")};const defaultConfiguration={onError:throwOnError,collectAllErrors:false,onFinishSuccess:onFinishSuccessDefault,onFinishWithErrors:onFinishWithErrorsDefault};const checkShapeCollectOneError=(conf,schema,object)=>{const requiredKeys=Object.keys(schema).filter(_utils.isRequiredKey);const optionalKeys=Object.keys(schema).filter(_utils.isOptionalKey);let areAllValid=optionalKeys.every(keyName=>{const keyNameStripped=keyName.replace(_utils.optionalRegex,"");return isValidType(conf,[undefined,schema[keyName]],object[keyNameStripped],object,keyNameStripped)});if(!areAllValid)return conf.onError(formatErrorMessage(schema[keyName],object[keyNameStripped]));areAllValid=requiredKeys.every(keyName=>isValidType(conf,schema[keyName],object[keyName],object,keyName));if(!areAllValid)return conf.onError(formatErrorMessage(schema,object));const regexKeys=Object.keys(schema).filter(_utils.isRegExp);const untestedKeys=Object.keys(object).filter(key=>!requiredKeys.includes(key));areAllValid=regexKeys.every(regexpString=>untestedKeys.filter(keyName=>(0,_utils.stringToRegExp)(regexpString).test(keyName)).every(keyName=>isValidType(conf,schema[regexpString],object[keyName],object,keyName)));if(areAllValid)return true;return conf.onError(formatErrorMessage(schema,object))};exports.checkShapeCollectOneError=checkShapeCollectOneError;const parseToArray=errorOrErrors=>{if(Array.isArray(errorOrErrors)){return errorOrErrors}else{return[errorOrErrors]}};const checkShapeCollectAllErrors=(conf,schema,object,path=[])=>{const requiredKeys=Object.keys(schema).filter(_utils.isRequiredKey);const optionalKeys=Object.keys(schema).filter(_utils.isOptionalKey);const regexKeys=Object.keys(schema).filter(_utils.isRegExp);const untestedKeys=Object.keys(object).filter(key=>!requiredKeys.includes(key)).filter(key=>!optionalKeys.map(k=>k.replace(_utils.optionalRegex,"")).includes(key));const optionalError=[];for(const keyName of optionalKeys){try{const keyNameStripped=keyName.replace(_utils.optionalRegex,"");const currentPath=[...path,keyNameStripped];let valid=isValidType(conf,[undefined,schema[keyName]],object[keyNameStripped],object,keyNameStripped,currentPath);if(valid)continue;return conf.onError(formatErrorMessage(schema[keyName],object[keyNameStripped],currentPath))}catch(error){optionalError.push(...parseToArray(error))}}let requiredErrors=[];for(const keyName of requiredKeys){try{const currentPath=[...path,keyName];let valid=isValidType(conf,schema[keyName],object[keyName],object,keyName,currentPath);if(valid)continue;return conf.onError(formatErrorMessage(schema[keyName],object[keyName],currentPath))}catch(error){requiredErrors.push(...parseToArray(error))}}let regexErrors=[];for(const regexpString of regexKeys){let keys=untestedKeys.filter(keyName=>(0,_utils.stringToRegExp)(regexpString).test(keyName));for(const keyName of keys){try{const currentPath=[...path,keyName];let valid=isValidType(conf,schema[regexpString],object[keyName],object,keyName,currentPath);if(valid)continue;return conf.onError(formatErrorMessage(schema[regexpString],object[keyName],currentPath))}catch(error){regexErrors.push(...parseToArray(error))}}}const errors=[...regexErrors,...requiredErrors,...optionalError];if(errors.length>0){throw errors}return true};exports.checkShapeCollectAllErrors=checkShapeCollectAllErrors;const checkShape=(conf,...args)=>conf.collectAllErrors?checkShapeCollectAllErrors(conf,...args):checkShapeCollectOneError(conf,...args);const whatKindIs=type=>{if((0,_utils.isType)(Object)(type))return"schema";if((0,_utils.isPrimitive)(type))return"primitive";if((0,_utils.isConstructor)(type))return"constructor";if((0,_utils.isCustomValidator)(type))return"function";if((0,_utils.isType)(Array)(type))return"enum";if((0,_utils.isType)(RegExp)(type))return"regex";throw new Error("Invalid type "+(0,_utils.stringify)(type))};const isValidType=(conf=defaultConfiguration,type,value,rootValue,keyName,path)=>{const kind=whatKindIs(type);switch(kind){case"regex":return(0,_utils.checkRegExp)(type,value);case"primitive":return value===type;case"constructor":return(0,_utils.isType)(type)(value);case"enum":return type.some(_type=>isValidType(conf,_type,value,rootValue,keyName));case"schema":return value&&checkShape(conf,type,value,path);case"function":return type(value,rootValue,keyName);default:return false;}};exports.isValidType=isValidType;const run=conf=>(...types)=>value=>{const errors=[];for(const type of types){try{const valid=isValidType(conf,type,value);if(valid)continue;throw conf.onError(formatErrorMessage(type,value))}catch(error){errors.push(...parseToArray(error));if(!conf.collectAllErrors)break}}if(errors.length>0){return conf.onFinishWithErrors(errors)}return conf.onFinishSuccess()};const config=({onError=throwOnError,collectAllErrors=false,onFinishSuccess=onFinishSuccessDefault,onFinishWithErrors=onFinishWithErrorsDefault}=defaultConfiguration)=>run({onError,collectAllErrors,onFinishSuccess,onFinishWithErrors});exports.config=config;const isValid=config({onFinishWithErrors:()=>false,collectAllErrors:false});exports.isValid=isValid;const isValidOrLog=config({onError:err=>console.error(err)||false,collectAllErrors:false});exports.isValidOrLog=isValidOrLog;const hasErrors=config({onFinishWithErrors:errors=>errors,onFinishSuccess:()=>null,collectAllErrors:true});exports.hasErrors=hasErrors;const isValidOrLogAllError=config({onFinishWithErrors:()=>false,onError:err=>console.error(err)||false,collectAllErrors:true});exports.isValidOrLogAllError=isValidOrLogAllError;const isValidOrThrowAllError=config({onFinishWithErrors:()=>false,onError:err=>console.error(err)||false,collectAllErrors:true});exports.isValidOrThrowAllError=isValidOrThrowAllError;const isValidOrThrow=config({});exports.isValidOrThrow=isValidOrThrow;var _default=isValidOrThrow;exports.default=_default;