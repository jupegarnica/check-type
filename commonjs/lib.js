"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.mustBe=exports.mustBeOrThrowAllErrors=exports.mustBeOrThrowAll=exports.isValidOrLogAllErrors=exports.isValidOrLogAll=exports.hasErrors=exports.isValidOrLog=exports.isValid=exports.mustBe=void 0;var _helpers=require("./helpers.js");var _constructors=require("./constructors.js");const onValidDefault=()=>true;const onInvalidDefault=error=>{throw error};const logErrorsAndReturnFalse=error=>{if(error instanceof AggregateError){console.group(error.name+":",error.message);error.errors.forEach(logErrorsAndReturnFalse);console.groupEnd(error.name+":")}else{console.error(error&&error.message||error)}return false};const formatErrorMessage=data=>{const{type,value,path,kind}=data;let _value=(0,_helpers.stringify)(value);let _type=(0,_helpers.stringify)(type);let _kind=kind||(0,_helpers.whatTypeIs)(type);let _path=path.length?`At path /${path.join("/")} `:"";let _typeString=kind==="serie"?_type.replace(/[\[\]]/g,""):_type;return`${_path}${_value} do not match ${_kind} ${_typeString}`};const createError=data=>{data.$Error=data.$Error||_constructors.TypeValidationError;data.path=data.path||[];data.message=formatErrorMessage(data);return new data.$Error(data.message,data)};const createAggregateError=(errors,data)=>{data.$Error=data.$Error;data.path=data.path||[];data.message=formatErrorMessage(data);return new data.$Error(errors,data.message,data)};const throwError=data=>{throw createError(data)};const throwErrors=(errors,data)=>{if(errors.length===1)throw errors[0];throw createAggregateError(errors,data)};const mapError=(error,data)=>{if(!error.raw)return error;data.path=data.path||[];const overriddenPath={...error.raw,path:[...data.path,...error.raw.path],$Error:error.constructor};if(error instanceof AggregateError){const errors=error.errors.map(e=>mapError(e,data));return createAggregateError(errors,overriddenPath)}else{return createError(overriddenPath)}};const reThrowError=(error,data)=>{throw mapError(error,data)};const truthyOrThrow=(input,data)=>{if(input)return input;throwError(data)};const updateRef=(ref,key,value)=>{try{ref[key]=value}catch{}};const validSchemaOrThrow=data=>{const{behavior,type:schema,value:object,root=object,path=[]}=data;if(!(object instanceof Object||typeof object==="string")){return throwError(data)}const mustUpdateRef=behavior.name==="mustBe";let clonedObject=object;if(mustUpdateRef){clonedObject=(0,_helpers.deepClone)(object)}let requiredErrors=[];const requiredKeys=Object.keys(schema).filter(_helpers.isRequiredKey);for(const keyName of requiredKeys){try{let newValue=isValidTypeOrThrow({behavior,type:schema[keyName],value:clonedObject[keyName],root,keyName,path:[...path,keyName]});mustUpdateRef&&updateRef(clonedObject,keyName,newValue)}catch(error){if(!behavior.collectAllErrors){throw error}requiredErrors.push(error)}}const optionalError=[];const optionalKeys=Object.keys(schema).filter(_helpers.isOptionalKey).filter(key=>!requiredKeys.includes(key.replace(_helpers.optionalRegex,"")));for(const keyName of optionalKeys){try{const keyNameStripped=keyName.replace(_helpers.optionalRegex,"");let value=clonedObject[keyNameStripped];if(!(0,_helpers.isNullish)(value)){let type=schema[keyName];let newValue=isValidTypeOrThrow({behavior,type,value,root,keyName:keyNameStripped,path:[...path,keyNameStripped]});mustUpdateRef&&updateRef(clonedObject,keyNameStripped,newValue)}}catch(error){if(!behavior.collectAllErrors){throw error}optionalError.push(error)}}let regexErrors=[];const regexKeys=Object.keys(schema).filter(_helpers.isRegExp);const untestedKeys=Object.keys(clonedObject).filter(key=>!requiredKeys.includes(key)).filter(key=>!optionalKeys.map(k=>k.replace(_helpers.optionalRegex,"")).includes(key));for(const regexpString of regexKeys){let keys=untestedKeys.filter(keyName=>(0,_helpers.stringToRegExp)(regexpString).test(keyName));for(const keyName of keys){try{let newValue=isValidTypeOrThrow({behavior,type:schema[regexpString],value:clonedObject[keyName],root,keyName,path:[...path,keyName]});mustUpdateRef&&updateRef(clonedObject,keyName,newValue)}catch(error){if(!behavior.collectAllErrors){throw error}regexErrors.push(error)}}}const errors=[...regexErrors,...requiredErrors,...optionalError];if(errors.length>0){throwErrors(errors,{...data,$Error:_constructors.SchemaValidationError,kind:"schema"})}return clonedObject};const validMainValidatorOrThrow=data=>{const{type:fn,value}=data;try{if(fn.applyDefault&&(data.behavior.name==="mustBe"||data.behavior.name==="applyDefault")){return fn(value)}else{let overrideBehavior={...data.behavior,onValid:onValidDefault,onInvalid:onInvalidDefault};return fn(value,{[_helpers.configurationSymbol]:overrideBehavior})}}catch(error){if(error.raw){reThrowError(error,data)}throw error}};const validCustomValidatorOrThrow=data=>{const{type:fn,value,root,keyName}=data;return truthyOrThrow(fn(value,root,keyName),data)};const validConstructorOrThrow=data=>truthyOrThrow((0,_helpers.checkConstructor)(data.type,data.value),data);const validPrimitiveOrThrow=data=>truthyOrThrow(data.value===data.type,data);const validRegExpOrThrow=data=>truthyOrThrow(data.value.constructor===String&&(0,_helpers.checkRegExp)(data.type,data.value),data);const validSeriesOrThrow=(behavior,types,value)=>{const errors=[];let valueTransformed=value;for(const type of types){try{valueTransformed=isValidTypeOrThrow({behavior,type,value})}catch(error){errors.push(error);if(!behavior.collectAllErrors)break}}if(errors.length>0){throwErrors(errors,{type:types,value,$Error:_constructors.SerieValidationError,kind:"serie"})}return valueTransformed};const validEnumOrThrow=data=>{const{behavior,type:types,value,root,keyName,path}=data;const errors=[];for(const type of types){try{return isValidTypeOrThrow({behavior,type,value,root,keyName,path})}catch(error){errors.push(error)}}throwErrors(errors,{...data,$Error:_constructors.EnumValidationError,kind:"enum"})};const isValidTypeOrThrow=data=>{switch((0,_helpers.whatTypeIs)(data.type)){case"regex":validRegExpOrThrow(data);return data.value;case"primitive":validPrimitiveOrThrow(data);return data.value;case"constructor":validConstructorOrThrow(data);return data.value;case"enum":return validEnumOrThrow(data);case"schema":return validSchemaOrThrow(data);case"validator":return validCustomValidatorOrThrow(data);case"main-validator":return validMainValidatorOrThrow(data);case"invalid":throw new SyntaxError(`checking with validator ${(0,_helpers.stringify)(data.type)} not supported`);}};function createValidator(types,behavior){function validator(value,secretArg){let currentBehavior=behavior;if(secretArg&&secretArg[_helpers.configurationSymbol]){currentBehavior=secretArg[_helpers.configurationSymbol]}let newValue=value;try{newValue=validSeriesOrThrow(currentBehavior,types,value)}catch(error){return currentBehavior.onInvalid(error,newValue)}return currentBehavior.onValid(newValue)}validator[_helpers.validatorSymbol]=true;validator.displayName=`${behavior.name}(${types.map(_helpers.stringify)})`;if(behavior.name==="mustBe"){validator.or=createOr(types,{...behavior})}if(behavior.name==="applyDefault"){validator.applyDefault=true}return validator}const applyDefault=defaultValue=>(error,value)=>{if(defaultValue instanceof Function)return defaultValue(value,error);return defaultValue};const createOr=(types,behavior)=>defaultValue=>createValidator(types,{...behavior,onInvalid:applyDefault(defaultValue),name:"applyDefault"});const returnValue=value=>value;const run=behavior=>(...types)=>createValidator(types,behavior);const config=({collectAllErrors=false,onValid=onValidDefault,onInvalid=onInvalidDefault,applyTransformation=false,applyDefault=false,name="mustBe"})=>run({collectAllErrors,onValid,onInvalid,applyTransformation,applyDefault,name});const mustBe=config({onValid:returnValue,name:"mustBe"});exports.mustBe=mustBe;const isValid=config({onInvalid:()=>false,name:"isValid"});exports.isValid=isValid;const isValidOrLog=config({onInvalid:logErrorsAndReturnFalse,name:"isValidOrLog"});exports.isValidOrLog=isValidOrLog;const flatAggregateError=error=>{if(error instanceof AggregateError){let errors=error.errors.flatMap(flatAggregateError);return errors}else{return[error]}};const hasErrors=config({onInvalid:error=>flatAggregateError(error),onValid:()=>null,name:"hasErrors",collectAllErrors:true});exports.hasErrors=hasErrors;const isValidOrLogAll=config({onInvalid:logErrorsAndReturnFalse,name:"isValidOrLogAll",collectAllErrors:true});exports.isValidOrLogAll=isValidOrLogAll;const isValidOrLogAllErrors=isValidOrLogAll;exports.isValidOrLogAllErrors=isValidOrLogAllErrors;const mustBeOrThrowAll=config({collectAllErrors:true,name:"mustBeOrThrowAll"});exports.mustBeOrThrowAll=mustBeOrThrowAll;const mustBeOrThrowAllErrors=mustBeOrThrowAll;exports.mustBeOrThrowAllErrors=mustBeOrThrowAllErrors;const mustBe=config({});exports.mustBe=mustBe;var _default=mustBe;exports.default=_default;