"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.isConstructor=isConstructor;exports.default=exports.isValidOrThrow=exports.isValidOrLog=exports.isValid=exports.setOnError=exports.InvalidType=exports.isValidType=exports.checkShape=exports.isPrimitive=exports.isNormalFunction=exports.isInstanceOf=exports.isType=void 0;function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true})}else{obj[key]=value}return obj}const isType=type=>val=>![undefined,null].includes(val)&&val.constructor===type;exports.isType=isType;const isInstanceOf=type=>val=>val instanceof type;exports.isInstanceOf=isInstanceOf;const isNormalFunction=f=>typeof f==="function"&&(!f.name||f.name[0]===f.name[0].toLowerCase());exports.isNormalFunction=isNormalFunction;function isConstructor(f){if(isNormalFunction(f))return false;try{new f}catch(err){return false}return true}const isPrimitive=value=>!(value instanceof Object);exports.isPrimitive=isPrimitive;const checkObject=(whatToDo,types,props)=>{const propsTypes=Object.keys(types).filter(notIsRegExp);const regExpToCheck=Object.keys(types).filter(isRegExp);const untestedReceivedProps=Object.keys(props).filter(key=>!propsTypes.includes(key));let allValids=[];propsTypes.forEach(propName=>{allValids.push(whatToDo(types[propName],props[propName],props,propName))});regExpToCheck.forEach(regexpString=>{untestedReceivedProps.forEach(propName=>{if(stringToRegExp(regexpString).test(propName)){allValids.push(whatToDo(types[regexpString],props[propName],props,propName))}})});return allValids.every(Boolean)};const checkShape=(types,props)=>checkObject(isValidType,types,props);exports.checkShape=checkShape;const isValidType=(type,value,rootValue,keyName)=>{if(isType(RegExp)(type)){return checkRegExp(type,value)}else if(isPrimitive(type)){return value===type}else if(isConstructor(type)){return isType(type)(value)}else if(isType(Array)(type)){return type.some(_type=>isValidType(_type,value,rootValue,keyName))}else if(isType(Object)(type)&&value instanceof Object){return checkShape(type,value)}else if(isNormalFunction(type)){return type(value,rootValue,keyName)}return false};exports.isValidType=isValidType;const toString=JSON.stringify;const checkRegExp=(regExp,value)=>regExp.test(value);const stringToRegExp=string=>new RegExp(eval(string));const isRegExp=value=>value&&/^\/.+\/$/.test(value);const notIsRegExp=value=>!isRegExp(value);class InvalidType extends Error{constructor(...args){super(...args);_defineProperty(this,"name",InvalidType)}}exports.InvalidType=InvalidType;const throwOnError=err=>{throw new InvalidType(err)};const check=error=>type=>value=>{try{return isValidType(type,value)||error(`value ${toString(value)} do not match type ${type}`)}catch(err){return error(err)}};const setOnError=onError=>check(onError);exports.setOnError=setOnError;const isValid=setOnError(()=>false);exports.isValid=isValid;const isValidOrLog=setOnError(err=>console.error(err));exports.isValidOrLog=isValidOrLog;const isValidOrThrow=setOnError(throwOnError);exports.isValidOrThrow=isValidOrThrow;var _default=isValidOrThrow;exports.default=_default;
//# sourceMappingURL=index.js.map