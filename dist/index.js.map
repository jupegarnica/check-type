{"version":3,"sources":["../src/index.js"],"names":["isType","type","val","undefined","includes","constructor","isInstanceOf","isNormalFunction","f","name","toLowerCase","isConstructor","err","isPrimitive","value","Object","checkObject","whatToDo","types","props","propsTypes","keys","filter","notIsRegExp","regExpToCheck","isRegExp","untestedReceivedProps","propName","allValids","forEach","push","regexpString","stringToRegExp","test","every","Boolean","checkShape","isValidType","RegExp","checkRegExp","Array","some","_type","toString","JSON","stringify","regExp","string","eval","onError","check","error"],"mappings":"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","sourcesContent":["export const isType = type => val =>\n  ![undefined, null].includes(val) && val.constructor === type;\n\nexport const isInstanceOf = type => val => val instanceof type;\n\nexport const isNormalFunction = f =>\n  typeof f === 'function' &&\n  (!f.name || f.name[0] === f.name[0].toLowerCase());\n\nexport function isConstructor(f) {\n  // detect is a normal function (anonymous or its name starts with lowercase)\n  if (isNormalFunction(f)) return false;\n\n  try {\n    new f();\n  } catch (err) {\n\n    return false;\n  }\n  return true;\n}\n\nexport const isPrimitive = value => !(value instanceof Object);\n// export const isPrimitive = value => Object(value) !== value;\n\nconst checkObject = (whatToDo, types, props) => {\n  const propsTypes = Object.keys(types).filter(notIsRegExp);\n  const regExpToCheck = Object.keys(types).filter(isRegExp);\n\n  const untestedReceivedProps = Object.keys(props).filter(\n    propName => !propsTypes.includes(propName),\n  );\n  let allValids = [];\n\n  propsTypes.forEach(propName => {\n    allValids.push(\n      whatToDo(\n        types[propName],\n        props[propName],\n        props,\n        propName,\n      ),\n    );\n  });\n  regExpToCheck.forEach(regexpString => {\n    untestedReceivedProps.forEach(propName => {\n      if (stringToRegExp(regexpString).test(propName)) {\n        allValids.push(\n          whatToDo(\n            types[regexpString],\n            props[propName],\n            props,\n            propName,\n          ),\n        );\n      }\n    });\n  });\n  return allValids.every(Boolean);\n};\n\nexport const checkShape = (types, props) =>\n  checkObject(isValidType, types, props);\n\nexport const isValidType = (type, value) => {\n  if (isType(RegExp)(type)) {\n    return checkRegExp(type, value);\n  } else if (isPrimitive(type)) {\n    return value === type;\n  } else if (isConstructor(type)) {\n    return isType(type)(value);\n  } else if (isType(Array)(type)) {\n    return type.some(_type => isValidType(_type, value));\n  } else if (isType(Object)(type) && value instanceof Object) {\n    return checkShape(type, value);\n  } else if (isNormalFunction(type)) {\n    return type(value);\n  }\n  return false;\n};\n\nconst toString = JSON.stringify;\n\nconst checkRegExp = (regExp, value) => regExp.test(value);\nconst stringToRegExp = string => new RegExp(eval(string));\nconst isRegExp = value => value && /^\\/.+\\/$/.test(value);\nconst notIsRegExp = value => !isRegExp(value);\n\nconst onError = (err) => {\n  // console.error(err);\n  throw err;\n};\nconst check = (type, error = onError) => (value) => {\n  try {\n    return (\n      isValidType(type, value) ||\n      error(\n        `value ${toString(\n          value,\n        )} do not match type ${(type)}`,\n      )\n    );\n  } catch (err) {\n    return error(err);\n  }\n};\n\n\nexport default check;\n"],"file":"index.js"}